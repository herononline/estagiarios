# Porque Go
> pq eu gosto

mentira Ã© isso nÃ£o, na verdade eu acho que Go Ã© uma boa linguagem pra iniciantes porque ela Ã© muito simples, tem uma boa biblioteca padrÃ£o (nÃ£o precisa instalar muita coisa), e tambÃ©m ele expÃµe algumas coisas que outras linguagens de programaÃ§Ã£o vÃ£o esconder pra vocÃªs ou atÃ© deixar de forma opcional

Go usa um coletor de lixo (garbage collector) https://pt.wikipedia.org/wiki/Coletor_de_lixo_(inform%C3%A1tica)

entÃ£o vocÃªs nÃ£o vÃ£o precisar tanto com gerenciamento de memoria manual, isso Ã© bom porque outras linguagens com C e C++ requerem esse gerenciamento de memoria manual, entÃ£o se vocÃªs alocarem algo na heap precisariam desalocar, no Go isso Ã© apenas coletado pelo coletor de lixo, e vocÃªs ainda conseguem trabalhar para manter coisas na stack, entÃ£o dÃ¡ pra garantir um desempenho legal com Go, ela Ã© uma das linguagens "novas" (acho que Ã© de 2009 ou 2010 ahsudha) famosinhas para backend e serviÃ§os da web/cloud, jÃ¡ que ela nasceu pra resolver varios problemas que a Google enfrentava na epoca, entÃ£o Go Ã© gostosinho de programar

* me avisem se voces nao souberem oque Ã© stack ou heap, mas isso nao Ã© uma coisa que vocÃªs precisam saber muito no mundo moderno (mas bons programadores sabem oque Ã© isso viu viu viu viu ğŸ‘€), ainda mais se estiver com linguagens como python e javascript hauhauh)

# O programinha que criamos

> antes sÃ³ queria deixar claro que go Ã© uma linguagem com uma biblioteca padrÃ£o muito rica, entÃ£o dÃ¡ pra fazer muita coisa sem instalar nada de fora, inclusive vocÃªs poderiam fazer esse serviÃ§o web usando apenas a biblioteca padrÃ£o com o `net/http` do Go, essas bibliotecas que vamos usar apenas facilitam isso, porque o net/http segue a ideia de ser algo muito simples, entÃ£o para um serviÃ§o da web ela poderia exigir muito codigo que essas bibliotecas jÃ¡ implementam (inclusive o Gin usa net/http por baixo dos panos )

vou seguir o codigo com vocÃªs comentando cada parte:
```Go
1   package main
2   
3   import (
4     "net/http"
5   
6     "github.com/gin-gonic/gin"
7   )
8   
9   func main() {
10    r := gin.Default()
11    r.GET("/ping", func(c *gin.Context) {
12      c.JSON(http.StatusOK, gin.H{
13        "message": "pong",
14      })
15    })
16    r.Run() // listen and serve on 0.0.0.0:8080 (for windows "localhost:8080")
17  }
```

```
1   package main
```

esse Ã© o ponto de entrada do seu programa Go, praticamente todo programa Go tem um package main e uma funÃ§Ã£o main(), aqui Ã© o entrypoint para o programa que vai ser compilado

```Go
3   import (
4     "net/http"
5   
6     "github.com/gin-gonic/gin"
7   )
``` 
essa aqui sÃ£o as importaÃ§Ãµes que fazemos para esse programa, se vocÃªs leram a paradinha que falei dos modulos go vocÃªs vÃ£o reparar que `github.com/gin-gonic/gin` Ã© um modulo externo, Go Ã© diferente do Nodejs, que tem um registry padrÃ£o, no go vocÃª pode hospedar seu codigo onde quiser, go vai fazer um fetch nas dependencias e adicionar ao seu projeto, isso Ã© muito bom, vez ou outra vocÃªs vou ouvir que o NPM foi hackeado, ou tÃ¡ fora de ar, ou que tal biblioteca infectada afetou milhÃµes de projetos hsauhau, no Go vocÃª tem controle total de onde vai botar seu codigo para outras pessoas usarem, vocÃª pode atÃ© mesmo deixar ele privado, apagar a biblioteca pra sempre (no NPM existem regras pra isso), enfim, vocÃª tem muito controle, entÃ£o sempre que vocÃªs verem um modulo que Ã© um link, significa que Ã© uma dependencia externa e o caminho Ã© onde o Go vai baixar o codigo, vocÃªs podem atÃ© mesmo abrir o link e conferir todo o codigo da biblioteca `github.com/gin-gonic/gin`

o `net/http` nÃ£o possui um link de registry porque ele faz parte da biblioteca padrÃ£o do Go, ela Ã© instalada na maquina de vocÃªs junto com a instalaÃ§Ã£o do Compilador, entÃ£o ela tÃ¡ disponivel pra todo mundo que programa em Go :)

```Go
9   func main() {
```

`func main()` define a funÃ§Ã£o main, o entrypoint para o cÃ³digo do seu programa

```Go
10    r := gin.Default()
11    r.GET("/ping", func(c *gin.Context) {
12      c.JSON(http.StatusOK, gin.H{
13        "message": "pong",
14      })
15    })
16    r.Run() // listen and serve on 0.0.0.0:8080 (for windows "localhost:8080")
17  }
```

`10    r := gin.Default()` essa Ã© a syntax do go para `declaraÃ§Ã£o` + `definiÃ§Ã£o`, normalmente vocÃªs vÃ£o ver linguagens fazendo algo como `var/const/let/type = valor`, se vocÃªs nÃ£o sabem a diferenÃ§a de declaraÃ§Ã£o para definiÃ§Ã£o me perguntem aÃ­ que eu explico, (eu realmente nÃ¡Ìƒo sei como foram as aulas de vocÃªs hfaudshfua)

enfim, nessa funÃ§Ã£o basicamente cria e retorna uma instancia do Gin (framework que estamos usando), se vocÃªs passarem o nome na funÃ§Ã£o (`.Default()`), vocÃªs conseguem ver a documentaÃ§Ã£o dela, vocÃªs tambÃ©m pode clicar nela com o lado direito e pular para definiÃ§Ã£o, com o codigo fonte da biblioteca com o texto da documentaÃ§Ã£o explicando a funÃ§Ã£o:

```Go
// Default returns an Engine instance with the Logger and Recovery middleware already attached.
func Default(opts ...OptionFunc) *Engine {
	debugPrintWARNINGDefault()
	engine := New()
	engine.Use(Logger(), Recovery())
	return engine.With(opts...)
}
``` 

sÃ³ mostrei isso sÃ³ porque essa uma das filosofias do Go, o cÃ³digo das bibliotecas estÃ¡ disponivel pra vocÃª, entÃ£o se vocÃª usa uma biblioteca, vocÃª tem todo o cÃ³digo dela, e nÃ£o apenas cabeÃ§alhos e definiÃ§Ãµes assim com Javascript ou C.

```Go
11    r.GET("/ping", func(c *gin.Context) {
12      c.JSON(http.StatusOK, gin.H{
13        "message": "pong",
14      })
15    })
```

aqui chamamos a nossa engine que colocamos o nome de `r`, que Ã© do tipo `*gin.Engine`, jÃ¡ que ela Ã© uma engine, podemos usar um dos metodos de uma `gin.Engine`: `GET`

> O metodo GET Ã© um metodo do protocolo HTTP, se nÃ£o me engano ele foi definido no HTTP 1.0, entÃ£o pode ter certeza que esse metodo vai ser suportado por quase tudo huahu

O metodo GET do Gin pede como primeiro argumento um caminho para  rota, no caso colocamos o caminho como '`/ping`', quando nossa aplicaÃ§Ã£o estiver rodando, toda vez que ela receber um GET para /ping, ele vai executar o segundo argumento, que Ã© uma `gin.HandlerFunc`, vocÃªs podem olhar no cÃ³digo do Gin oque Ã© uma HandleFunc, basicamente Ã© uma funÃ§Ã£o com essa syntax aqui: `HandlerFunc func(c *gin.Context)`, entÃ£o criamos uma funÃ§Ã£o anonima (funÃ§Ã£o sem nome dentro de outra funÃ§Ã£o) com essa syntax, exatamente igual, eu sempre achei a syntax de passar uma funÃ§Ã£o como argumento estranho huahua, ainda mais nesse jeito anonimo que nÃ£o passamos nome nem nada hausuhas, o cÃ³digo fica muito estranho com vÃ¡rias ({}), entÃ£o Ã© normal se estranharem tambÃ©m, inclusive vocÃªs poderiam criar essa funÃ§Ã£o fora e sÃ³ usar ela, deixando mais fÃ¡cil de ler e talvez entender:

```Go 
// mesma coisa da outra mas nÃ£o anonima 
func sendJSONPongHandler(c *gin.Context) {
    c.JSON(http.StatusOK, gin.H{
      "message": "pong",
    })
}

func main() {
  r := gin.Default()
  r.GET("/ping", sendJSONPongHandler) // mesma coisa
  r.Run() // listen and serve on 0.0.0.0:8080 (for windows "localhost:8080")
}
```

Vamos dar uma olhadinha nessa funÃ§Ã£o haushasu, quase finalizando
```
func sendJSONPongHandler(c *gin.Context) {
    c.JSON(http.StatusOK, gin.H{
      "message": "pong",
    })
}
``` 
basicamente usamos o contexto do Gin, o contexto Ã© uma estrutura que encapsula tudo do HTTP e da requisiÃ§Ã£o, ele consegue enviar as respostas para o requisitante, consegue saber quem requisitou, consegue pegar metadados, e outras coisinhas

> essa parada de contexto se nÃ£o me engano foi popularizada por um framework Javascript chamada Express, entÃ£o quando temos acesso ao contexto assim no framework dizemos que ele Ã© inspirado no Express ("Express-like") hauhau}

EntÃ£o usamos a funÃ§Ã£o de resposta do contexto, respondendo o request que recebemos na nossa rota '`ping`', respondemos com um JSON que Ã© basicamente
 
```JSON
{
"message": "pong"
} 
``` 

> se vocÃªs nÃ£o souberem oque Ã© um JSON podem perguntar tambÃ©m 

no final metemos um 

```Go
16    r.Run() // listen and serve on 0.0.0.0:8080 (for windows "localhost:8080")
```

que Ã© basicamente pegar a engine que inicializamos e mandar ela ficar rodando, o Gin por padrÃ£o usa a porta `:8080` na rede

> eu esqueci de falar, mas isso aqui '`//`' em Go Ã© um comentario, tudo pra frente disso nÃ£o entra no programa compilado e Ã© totalmente ignorado, mas no Go vocÃª pode usar isso pra documentar o cÃ³digo, Ã© importante saber usar os comentÃ¡rios de forma inteligente, comentar tudo Ã© loucura tambÃ©m, com o tempo vocÃªs vÃ£o construindo intuiÃ§Ã£o pra isso, mas tem umas regrinhas de ouro hasuhau

isso de `porta` (port) vocÃªs devem ter estudado em redes, mas se nÃ£o estÃ£o familiarizados com isso recebam o conhecimento:

https://www.cloudflare.com/pt-br/learning/network-layer/what-is-a-computer-port/

--- 
# pronto, agora vocÃªs jÃ¡ sÃ£o devs backend ou fullstack

pra rodar essa parada vocÃªs usam o compilador do go, basicamente abram um terminal e rodem `go run main.go`, ou `go run .`, o compilador Ã© esperto e vai encontrar a main, compilar, e rodar o codigo na mesma hora, serviÃ§os web nÃ£o desligam muito (se desligar ou Ã© manutencao ou deu ruim), entÃ£o vocÃªs precisam deixar o serviÃ§o rodando para mandar requisiÃ§Ãµes, essa funÃ§Ã£ozinha Run() jÃ¡ vai manter ele rodando pra sempre, Ã© basicamente um loop infinito que nÃ£o para ahsuhsa (ao menos que vocÃªs desliguem o programa com CTRL+C ou matando o processo)

mas vamos testar agora, vocÃªs precisam de um programa para fazer requisiÃ§Ãµes a internet, um programa que consiga usar o protocolo HTTP pra isso, existem muitos, de terminal tem o `wget` ou `curl` (curl Ã© super famoso e carrega nas costas quase tudo hasuhas), mas como vamos fazer de uma forma visual e simples, vocÃªs jÃ¡ tem um programa instalado que faz requisiÃ§Ãµes GET facil facil hauhau, Ã© o navegador, entÃ£o basicamente acessem o ip local e entrem na porta 8080, 

sÃ³ abrir esse link aqui se o programa estiver rodando
`http://localhost:8080`

o navegador de vocÃªs vai fazer um GET nesse ip e renderizar a resposta na tela 

### (404 not found)
enganei vocÃªs hasdfuhasuf, (na vrdd eu sou burro), entÃ£o, essa hota que eu passei pra vocÃªs Ã© onde a aplicaÃ§Ã£o tÃ¡ rodando, quando vocÃªs tentarem acessar ela o nosso framework Ã© esperto e nÃ£o vai achar uma rota pra isso, e vai dar o 404 automaticamente, a rota que criamos nesse programa Ã© `/ping`, entÃ£o vocÃªs precisam acessar: `http://localhost:8080/ping`

se estiver tudo certo deu boa

> essa parada de redes vocÃªs vÃ£o estudar na faculdade tambÃ©m, entÃ£o se vocÃªs fizerem podem ficar tranquilos que vÃ£o estudar haushas, mas se quiserem aprender um pouco agora e por fora vou passar o basiquinho aqui do que vocÃªs vÃ£o precisar entender 

metodos HTTP:
https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Reference/Methods

oque Ã© uma API REST (oque comeÃ§amos a fazer):
https://www.redhat.com/pt-br/topics/api/what-is-a-rest-api

livro (se forem malucos hasuhas, mas provavelmente vÃ£o ver isso na faculdade, nÃ£o recomendo comprarem pq Ã© caro ashuhas e tem mais coisa do que vocÃªs precisam saber agora, mas caso algum dia estiverem no hype de ler um livro de programaÃ§Ã£o sobre redes da grossura de um tijolo fica ai a recomendaÃ§Ã£o):

https://archive.org/details/tanenbaum-rede-de-computadores-6a/mode/2up

> enfim, esse livro ai jÃ¡ vai do comeÃ§o atÃ© o final, e um junior hoje em dia nÃ£o precisa saber de tudo isso hauhsa, mas talvez vocáº½s vejam esse livrinho na faculdade entÃ£o joguei ele ai tambem

---

Ã© isso ai galera, mandaram bem, deem uma lida ai no que deixei de link (menos o livro hdfuashfudha), acho que a proxima coisa que vamos fazer Ã© o banco de dados, mas tÃ´ pensando ainda haushas, por agora fico ai pra duvidas 